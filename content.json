{"meta":{"title":"Legend","subtitle":"","description":"思念之人所在之处,便是我的归宿","author":"Legend","url":"http://example.com","root":"/"},"pages":[{"title":"tags","date":"2022-09-05T11:40:18.000Z","updated":"2022-09-05T11:40:46.302Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2022-09-05T11:38:55.000Z","updated":"2022-09-05T13:57:14.903Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"search","date":"2022-09-05T11:43:50.000Z","updated":"2022-09-05T11:44:13.465Z","comments":true,"path":"search/index.html","permalink":"http://example.com/search/index.html","excerpt":"","text":""}],"posts":[{"title":"图片打包Zip压缩包文件流给前端","slug":"使用Zxing生成二维码并返回给前端","date":"2023-03-31T03:37:34.182Z","updated":"2023-05-15T09:18:42.312Z","comments":true,"path":"2023/03/31/使用Zxing生成二维码并返回给前端/","link":"","permalink":"http://example.com/2023/03/31/%E4%BD%BF%E7%94%A8Zxing%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81%E5%B9%B6%E8%BF%94%E5%9B%9E%E7%BB%99%E5%89%8D%E7%AB%AF/","excerpt":"","text":"# 图片打包 Zip 压缩包文件流给前端 # 前言: 本文实现将图片打包成 zip 流返回给前端，图片来源可以是 OSS 存储中获取的 url 下载，也可以是字节生成的图片字节流，直接打包成 zip 文件给前端 # 1. 导入包 &lt;!-- 二维码需要 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.zxing&lt;/groupId&gt; &lt;artifactId&gt;core&lt;/artifactId&gt; &lt;version&gt;3.4.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.zxing&lt;/groupId&gt; &lt;artifactId&gt;javase&lt;/artifactId&gt; &lt;version&gt;3.4.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 图片转换需要 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.3.24&lt;/version&gt; &lt;/dependency&gt; # 2. 工具类 package com.qrcode.until;/** * @ClassName QRCodeUtils * @Date 2023/3/29 9:53 * @Author legend */import com.google.zxing.BarcodeFormat;import com.google.zxing.EncodeHintType;import com.google.zxing.MultiFormatWriter;import com.google.zxing.client.j2se.MatrixToImageWriter;import com.google.zxing.common.BitMatrix;import com.google.zxing.qrcode.decoder.ErrorCorrectionLevel;import javax.imageio.ImageIO;import java.awt.*;import java.awt.image.BufferedImage;import java.io.ByteArrayOutputStream;import java.io.File;import java.io.IOException;import java.util.Base64;import java.util.HashMap;import java.util.Map;public class QRCodeUtils &#123; /** * 黑色 */ private static final int BLACK = 0xFF000000; /** * 白色 */ private static final int WHITE = 0xFFFFFFFF; /** * 宽 */ private static final int WIDTH = 2000; /** * 高 */ private static final int HEIGHT = 2000; /** * 图片高度增加 60 */ private static final int PIC_HEIGHT = HEIGHT + 120; /** * 二维码传图片 * * @param matrix * @return */ public static BufferedImage toBufferedImage(BitMatrix matrix) &#123; int width = matrix.getWidth(); int height = matrix.getHeight(); BufferedImage image = new BufferedImage(width, PIC_HEIGHT, BufferedImage.TYPE_INT_RGB); for (int x = 0; x &lt; width; x++) &#123; for (int y = 0; y &lt; PIC_HEIGHT; y++) &#123; image.setRGB(x, y, WHITE); &#125; &#125; for (int x = 0; x &lt; width; x++) &#123; for (int y = 0; y &lt; height; y++) &#123; image.setRGB(x, y, matrix.get(x, y) ? BLACK : WHITE); &#125; &#125; return image; &#125; /** * 生成二维码 * * @param content 扫描二维码的内容 * @param format 图片格式 jpg * 文件 * @throws Exception */ @SuppressWarnings(\"unchecked\") public static BufferedImage generateQrCode(String content, String format) throws Exception &#123; MultiFormatWriter multiFormatWriter = new MultiFormatWriter(); @SuppressWarnings(\"rawtypes\") Map hints = new HashMap(); // 设置 UTF-8， 防止中文乱码 hints.put(EncodeHintType.CHARACTER_SET, \"UTF-8\"); // 设置二维码四周白色区域的大小 hints.put(EncodeHintType.MARGIN, 5); // 设置二维码的容错性 hints.put(EncodeHintType.ERROR_CORRECTION, ErrorCorrectionLevel.H); // 画二维码 BitMatrix bitMatrix = multiFormatWriter.encode(content, BarcodeFormat.QR_CODE, WIDTH, HEIGHT, hints); BufferedImage image = toBufferedImage(bitMatrix); return image; &#125; /** * 把生成的图片写到指定路径 * * @param qrcFile 路径 * @param qrCodeContent 二维码内容 * @param pressText 增加的文字 * @throws Exception */ public static void generateQrCodeByPath(File qrcFile, String qrCodeContent, String pressText) throws Exception &#123; BufferedImage image = generateQrCode(qrCodeContent, \"jpg\"); Graphics g = image.getGraphics(); ((Graphics2D) g).setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON); // 设置字体，大小 Font font = new Font(\"黑体\", Font.PLAIN, 150); g.setFont(font); g.setColor(Color.black); FontMetrics metrics = g.getFontMetrics(font); // 文字在图片中的坐标 这里设置在中间 int startX = (WIDTH - metrics.stringWidth(pressText)) / 2; // int startY=HEIGHT+(PIC_HEIGHT-HEIGHT)/2; // 文字在二维码上面 int startY = PIC_HEIGHT - HEIGHT; // 文字在二维码下面 g.drawString(pressText, startX, startY); g.dispose(); image.flush(); try &#123; ImageIO.write(image, \"jpg\", qrcFile); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; /** * 把生成的图片返回到前端 * * @param qrCodeContent 二维码内容 * @throws Exception */ public static BufferedImage generateQrCodeBack( String qrCodeContent) throws Exception &#123; BufferedImage image = generateQrCode(qrCodeContent, \"jpg\"); Graphics g = image.getGraphics(); ((Graphics2D) g).setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON); image.flush(); return image; &#125; /** * 生成二维码并使用 Base64 编码 * * @param content 二维码内容 * @return 返回 base64 图片 * @throws Exception */ @SuppressWarnings(\"unchecked\") public static String getBase64QRCode(String content) throws Exception &#123; String format = \"png\"; MultiFormatWriter multiFormatWriter = new MultiFormatWriter(); @SuppressWarnings(\"rawtypes\") Map hints = new HashMap(); // 设置二维码四周白色区域的大小 hints.put(EncodeHintType.MARGIN, 10); // 设置二维码的容错性 hints.put(EncodeHintType.ERROR_CORRECTION, ErrorCorrectionLevel.H); // 画二维码 BitMatrix bitMatrix = multiFormatWriter.encode(content, BarcodeFormat.QR_CODE, WIDTH, HEIGHT, hints); BufferedImage image = MatrixToImageWriter.toBufferedImage(bitMatrix); ByteArrayOutputStream os = new ByteArrayOutputStream();// 新建流。 ImageIO.write(image, format, os);// 利用 ImageIO 类提供的 write 方法，将 bi 以 png 图片的数据模式写入流。 byte b[] = os.toByteArray();// 从流中获取数据数组。 String base64String = Base64.getEncoder().encodeToString(b); // Base64 编码 return base64String; &#125;&#125;# 3. 生成二维码 (代码片段) for (String uuid : uuidArray) &#123; // 使用 zxing 生成二维码 bufferedImage = QRCodeUtils.generateQrCodeBack(uuid); log.info(\"二维码生成成功\"); byte[] bytes = imageToBytes(bufferedImage); //MockMultipartFile 需要导入 spring-test 的依赖包 /* 这里自定义流程 可以将图片上传到 OSS 也可以直接获取生成的图片输出 * 本段代码实现的是直接将图片输出 * */ hashMap.put(uuid, bytes); log.info(\"完成\"); &#125;# 4. 将图片打包成 zip (代码片段) for (Map.Entry&lt;String, byte[]> entry : hashMap.entrySet()) &#123; // 获取到 oss 的图片路径，使用上传到 Oss 放开这两行代码// URL url = new URL(entry.getValue());// imageInputStream = url.openStream();imageInputStream= new ByteArrayInputStream(entry.getValue()); // 二维码图片名称 ZipEntry zipEntry = new ZipEntry(entry.getKey() + \".jpg\"); zipOutputStream.putNextEntry(zipEntry); int len; // 定义每次读取的字节数组 byte[] buffer = new byte[1024]; log.info(\"开始写入zip\"); while ((len = imageInputStream.read(buffer)) > 0) &#123; zipOutputStream.write(buffer, 0, len); &#125; &#125;# 5. 将图片转换成字节数组 private byte[] imageToBytes(BufferedImage bImg) &#123; ByteArrayOutputStream out = new ByteArrayOutputStream(); try &#123; ImageIO.write(bImg, \"jpg\", out); &#125; catch (IOException e) &#123; log.error(\"转成字节数组异常\",e); &#125; return out.toByteArray(); &#125;","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"}],"tags":[]},{"title":"Vue基础","slug":"Vue 基础","date":"2023-02-11T08:45:32.976Z","updated":"2023-02-17T06:15:05.691Z","comments":true,"path":"2023/02/11/Vue 基础/","link":"","permalink":"http://example.com/2023/02/11/Vue%20%E5%9F%BA%E7%A1%80/","excerpt":"","text":"# Vue 基础 # Vue 快速起步 # (1) 入门示例 body中,设置Vue管理的视图&lt;div id=\"app\">&lt;/div> 引入vue.js 实例化Vue对象 new Vue(); 设置Vue实例的选项:如el、data... new Vue(&#123;选项:值&#125;); 在&lt;div id='app'>&lt;/div>中通过使用data中的数据&lt;!DOCTYPE html>&lt;html lang=\"en\">&lt;head> &lt;meta charset=\"UTF-8\"> &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> &lt;title>Document&lt;/title> &lt;!-- 引入 vue.js 库 --> &lt;script src=\"js/vue-2.6.12.js\">&lt;/script>&lt;/head>&lt;body> &lt;div id=\"app\"> &lt;/div> &lt;script> // 创建 Vue 实例对象 var vm = new Vue(&#123; el:'#app', //Element 元素，表示当前 VM 管理的视图区 data:&#123; msg : \"Hello,欢迎学习VueJS!\" &#125; &#125;); &lt;/script>&lt;/body>&lt;/html># (2) Vue 实例的选项 el 作用:当前Vue实例所管理的html视图 值:通常是id选择器(或者是一个 HTMLElement 实例) 不要让el所管理的视图是html或者bodydata Vue 实例的数据对象，是响应式数据(数据驱动视图) 可以通过 vm.$data 访问原始数据对象console.log(vm.$data.msg); 等价于 console.log(vm.msg);methods 其值为可以一个对象 可以直接通过 VM 实例访问这些方法，或者在指令表达式中使用 //直接通过vm实例访问方法 vm.func1(); 或 &lt;button type=\"button\" v-on:click=\"func1\">我是按钮&lt;/button>&lt;!DOCTYPE html>&lt;html lang=\"en\">&lt;head> &lt;meta charset=\"UTF-8\"> &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> &lt;title>Document&lt;/title> &lt;!-- 引入 vue.js 库 --> &lt;script src=\"js/vue-2.6.12.js\">&lt;/script>&lt;/head>&lt;body> &lt;div id=\"app\"> &lt;br> - - &lt;br> &lt;button type=\"button\" v-on:click=\"func1\">我是按钮&lt;/button> &lt;/div> &lt;script> // 创建 Vue 实例对象 var vm = new Vue(&#123; el:'#app', //Element 元素，表示当前 VM 管理的视图区 不能指定为 body 或 html data:&#123; //vm 访问的 model 对象 msg : \"Hello,欢迎学习VueJS!\", stu:&#123;id:1,sname:'张三',sage:20&#125; &#125;, methods:&#123; func1()&#123; console.log(this); // 此时方法中的 this 表示当前 vm 实例 alert(this.msg); &#125;, func2:function()&#123; alert('func2()'); &#125;, func3:()=>&#123; console.log(this); // 箭头函数中的 this 表示的是 window 顶层对象，并不是 vm console.log(this.vm); // 当前窗口中的 vm 对象 &#125; &#125; &#125;); // 直接通过 vm 实例访问方法 vm.func3(); console.log(vm.msg); console.log(vm.stu); console.log(vm.$data.msg); &lt;/script>&lt;/body>&lt;/html># (3) 术语解释 a. 插值表达式 |- 动态呈现 data 中的数据，实现显示 [只要 data 中的数据改变，插值表达式会动态显示] 通过任何方式修改所绑定的数据，所显示的数据都会被实时替换 不能写 JS 语句，如：var a=10; 分支语句 循环语句 &lt;div id=&quot;app&quot;&gt; &#123;&#123;msg.split(\",\")&#125;&#125;&lt;br&gt; &#123;&#123;'是否成年:'+(age>=18 ? '成年' : '未成年')&#125;&#125; &lt;br&gt;&lt;br&gt; 年龄+1: &#123;&#123;age&#125;&#125;&lt;br&gt;&lt;br&gt; &#123;&#123;stu.id&#125;&#125; - &#123;&#123;stu.sname&#125;&#125; - &#123;&#123;stu.sage&#125;&#125;&lt;br&gt;&lt;br&gt; &lt;/div&gt; b. 指令 directive 都是以 v- 开头 l 指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM v-on 指令就是给标签绑定事件 |- 一般使用缩写式: @ v-on:事件 |- 例：v-on:click --@click v-on:blur ...# Vue 基础指令 常用指令有 v-for (用于循环遍历) 、v-if 、v-text、v-bind、v-on 等 # a. v-text 和 v-html 很像 innerText 和 innerHTML 首先，说明 v-text 与插值表达式区别: v-text 更新整个标签中的内容插值表达式: 更新标签中局部的内容&lt;body> &lt;div id=\"app\"> &lt;p v-text=\"msg\">这是一个段落!&lt;/p> &lt;p>这是一个段落,部份使用插值: &lt;/p> &lt;p v-html=\"msg\">这是一个段落!&lt;/p> &lt;/div> &lt;script> // 创建 Vue 实例对象 var vm = new Vue(&#123; el:'#app', data:&#123; msg:'&lt;font color=\"red\">hello&lt;/font>' &#125;, methods:&#123; &#125; &#125;); &lt;/script>&lt;/body># b. v-bind 绑定指令 (单向绑定) 可以绑定标签上的任何属性，可以使用得属性读取 vue 实例中的 data 中数据 比如： &lt;img v-bind:src=\"img\" /> 访问data中的img属性通常使用简写 : &lt;p> &lt;!-- v-bind 和：等价 --> &lt;img :src=\"img\" /> &lt;button type=\"button\" @click=\"changePic\">改变图片&lt;/button>&lt;br>&lt;/p>&lt;p> &lt;input type=\"text\" :value=\"name\" />&lt;/p>&lt;script> // 创建 Vue 实例对象 var vm = new Vue(&#123; el:'#app', data:&#123; img:'images/angel.gif', name:'Jack' &#125;, methods:&#123; changePic()&#123; this.img='images/dog1.jpg'; &#125; &#125; &#125;); &lt;/script># c. v-model (双向绑定) v-model 是 Vue 框架的一种内置的 API 指令，本质是一种语法糖写法。它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理。 v-model 的原理 (v-model 双向绑定等于 v-bind 和 v-on) 官方有说到，v-model 的原理其实是背后有两个操作： v-bind 绑定 value 属性的值； v-on 绑定 input 事件监听到函数中，函数会获取最新的值赋值到绑定的属性中； 如果我们在 v-model 后跟上 lazy 修饰符 (v-model.lazy)，那么会将绑定的事件切换为 change 事件，只有在提交时（比如回车）才会触发 v-model 后更上 trim 修饰符就能去除两边空格，v-model 后跟上 number 修饰符就能将内容当成数字处理 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;script src=&quot;https://cdn.staticfile.org/vue/3.2.36/vue.global.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;input v-model=&quot;message&quot;&gt; &lt;/div&gt; &lt;script&gt; const app = &#123; data() &#123; return &#123; message: 'legend!' &#125; &#125; &#125; Vue.createApp(app).mount('#app') &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; # d. v-on 注册事件指令 &lt;p> &lt;!-- 可以直接在 v-on 属性值中编写表达式 --> &lt;input type=\"button\" value=\"增加1\" @click=\"count+=1\"> &lt;/p> &lt;p> &lt;input type=\"button\" value=\"增加1\" @click=\"count+=1\"> &lt;/p> &lt;!-- 执行一个方法、这种写法可以传形参，特殊的形参 $event -->&lt;p> &lt;input type=\"button\" value=\"增加1\" @click=\"add($event)\">&lt;/p> &lt;!-- 执行一个方法、这种写法可以传形参，特殊的形参 $event -->&lt;p> &lt;input type=\"button\" value=\"增加1\" @click=\"add($event)\">&lt;/p>&lt;script> // 创建 Vue 实例对象 var vm = new Vue(&#123; el: '#app', data: &#123; count: 0 &#125;, methods: &#123; add(evt) &#123; this.count++; console.log(evt.target); //evt 通过 $event 传入，表示事件发生时的状态信息 &#125; &#125; &#125;);&lt;/script># e.v-for 循环语句 div id=&quot;app&quot;&gt; &lt;ol&gt; &lt;li v-for=&quot;(site, index) in sites&quot;&gt; &#123;&#123; index &#125;&#125; -&#123;&#123; site.text &#125;&#125; &lt;/li&gt; &lt;/ol&gt; &lt;/div&gt; &lt;script&gt; const app = &#123; data() &#123; return &#123; sites: [ &#123; text: 'Google' &#125;, &#123; text: 'Runoob' &#125;, &#123; text: 'Taobao' &#125; ] &#125; &#125; &#125; Vue.createApp(app).mount('#app') &lt;/script&gt; # Vue 生命周期 Vue 的生命周期就是 vue 实例从创建到销毁的全过程，也就是 new Vue () 开始就是 vue 生命周期的开始。 &lt;img src=&quot;https://www.wucq.top/f/7NIE/vue-life Cycle.png&quot; alt=&quot;vue-life Cycle&quot; style=&quot;zoom:50%;&quot; /&gt; 共有 8 个生命周期 钩子函数 # (1) 创建期间的生命周期函数  beforeCreate：实例刚在内存中被创建出来，此时，还没有初始化好 data 和 methods 属性 created：实例已经在内存中创建OK，此时 data 和 methods 已经创建OK，此时还没有开始 编译模板 beforeMount：此时已经完成了模板的编译，但是还没有挂载到页面中 mounted：此时，已经将编译好的模板，挂载到了页面指定的容器中显示# (2) 运行期间的生命周期函数  beforeUpdate：状态更新之前执行此函数， 此时 data 中的状态值是最新的，但是界面上显示的 数据还是旧的，因为此时还没有开始重新渲染DOM节点 updated：实例更新完毕之后调用此函数，此时 data 中的状态值 和 界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了# (3) 销毁期间的生命周期函数  beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。 destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。# 举个栗子: &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 引入vuejs --&gt; &lt;script src=&quot;js/vue-2.6.12.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;p id=&quot;p&quot;&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;input type=&quot;text&quot; v-model=&quot;msg&quot; /&gt; &lt;/div&gt; &lt;script&gt; // 创建Vue实例对象 var vm = new Vue(&#123; el:'#app', data:&#123; msg:'hello' &#125;, methods:&#123; printMsg()&#123; console.log(&quot;printMsg()执行了...&quot;); &#125; &#125;, beforeCreate() &#123;//实例刚在内存中被创建出来，此时，还没有初始化好 data 和 methods 属性 console.log(&quot;beforeCreated()执行了...&quot;); console.log(this.msg); //undefined this.printMsg(); //未定义 &#125;, created() &#123;//实例已经在内存中创建OK，此时 data 和 methods 已经创建OK，此时还没有开始 编译模板 console.log(&quot;created()执行了....&quot;); console.log(this.msg); this.printMsg(); console.log(&quot;访问模板元素:&quot;+document.getElementById(&quot;p&quot;).innerText); //&#123;&#123;msg&#125;&#125; &#125;, beforeMount() &#123; //此时已经完成了模板的编译，但是还没有挂载到页面中 console.log(&quot;beforeMount()执行了....&quot;); console.log(this.msg); this.printMsg(); console.log(&quot;访问模板元素:&quot;+document.getElementById(&quot;p&quot;).innerText); //&#123;&#123;msg&#125;&#125; &#125;, mounted() &#123; //已经将编译好的模板，挂载到了页面指定的容器中显示 console.log(&quot;mounted()执行了....&quot;); console.log(this.msg); this.printMsg(); console.log(&quot;访问模板元素:&quot;+document.getElementById(&quot;p&quot;).innerText); //&#123;&#123;msg&#125;&#125; &#125;, beforeUpdate() &#123; //状态更新之前执行此函数， 此时 data 中的状态值是最新的，但是界面上显示的 数据还是旧的 console.log(&quot;beforeUpdate()执行了....&quot;); console.log(this.msg); //data中的 console.log(&quot;访问模板元素:&quot;+document.getElementById(&quot;p&quot;).innerText); &#125;, updated() &#123; //实例更新完毕之后调用此函数，此时 data 中的状态值 和 界面上显示的数据，都已经完成了更新 console.log(&quot;updated()执行了....&quot;); console.log(this.msg); console.log(&quot;访问模板元素:&quot;+document.getElementById(&quot;p&quot;).innerText); &#125;, beforeDestroy() &#123; //实例销毁之前调用。在这一步，实例仍然完全可用 console.log(&quot;destroy()执行了....&quot;); console.log(this.msg); &#125;, destroyed() &#123; //Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁 console.log(&quot;destroyed()执行了....&quot;); console.log(this.msg); // 此时将不能再引用vm实例 &#125;, &#125;); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;","categories":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}],"tags":[]},{"title":"Redis","slug":"Redis","date":"2022-09-16T09:12:13.125Z","updated":"2023-02-17T06:15:51.798Z","comments":true,"path":"2022/09/16/Redis/","link":"","permalink":"http://example.com/2022/09/16/Redis/","excerpt":"","text":"# Redis redis 数据模型 redis 整合 springboot redis 的常用命令 redis 的相关类型操作 # 1.redis 简介 # 1. 数据模型 Redis 数据模型不仅仅与关系数据库管理系统（RDBMS）不同，也不同于任何简单的 NoSQL 键 - 值数据存储系统。 Redis 数据类型类似于编程语言的基础数据类型，因此开发人员感觉很自然，每个数据类型都支持适『用于其类型的操作』，以最大限度发挥每种数据类型的特性。 受支持的数据类型包括： string（ 字符串 ） hash（ 哈希 ） list（ 列表 ） set（ 集合 ） zset（ sorted set：有序集合 ） # 2. 优势 Redis 的优势包括它的速度、对富数据类型的支持、操作的原子性，以及通用性： 性能极高，它每秒可执行约 10k 个 SET 以及约 100k 个 GET 操作； 丰富的数据类型，Redis 对大多数开发人员已知的多数数据类型提供了原生支持，这使得各种问题得以轻松解决； 原子性，因为所有 Redis 操作都是原子性的，所以多个客户端会并发地访问一个 Redis 服务器器，获取相同的更新值； 丰富的特性，Redis 是一个多效用工具，有非常多的应用场景，包括缓存、消息队列（ Redis 原生支持发布 / 订阅 ）、短期应用程序数据据（ 比如 Web 会话 ）等 # 3. 通用命令简介 Redis 的常用的基础命令有： 命令 说明 ping PING 命令来测试客户端与 Redis 的连接是否正常。 连接正常时会收到回复 PONG set / get 使用 set 和 get 可以向 redis 设置数据、获取数据。 del 删除指定 key 的内容。 Keys * 查看当前库中所有的 key 值 一个 Redis 实例可以包括多个数据库。不过，一个 redis 实例最多可提供 16 个数据库，而且固定了以下标从 0 到 15 作为数据库名。客户端默认连接第 0 号数据库。 # 2. 在 spring 中使用 redis # step1: 依赖的准备 Spring Boot 提供了对 Redis 集成的组件包：spring-boot-starter-data-redis，它依赖于 spring-data-redis 和 lettuce 。 Spring Data Redis 的底层驱动有 2 种选择， 1.x 时代用的是 Jedis ，2.x 时代换成了 Lettuce 。 # 方式一：Jedis &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;exclusions&gt; &lt;!-- 从依赖关系中排除 --&gt; &lt;exclusion&gt; &lt;groupId&gt;io.lettuce&lt;/groupId&gt; &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;/dependency&gt; # 方式二: lettuce &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- lettuce 依赖于 commons-pool2 。但是不知道为什么， 它又不在 lettuce 的依赖关系中。所以要手动引入。--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt; &lt;/dependency&gt; # Step2:application 配置 spring.redis.host=localhost # 默认值就是 localhostspring.redis.port=6379 # 默认值就是 6379spring.redis.database=0 # 默认值就是 0spring.redis.password= # 默认值就是空spring: redis: database: 1 #连接几号数据库 host: 127.0.0.1 port: 6379# 3、Spring Data Redis Spring Data Redis 针对 api 进行了重新归类与封装，将同一类型的操作封装为 Operation 接口： 专有操作 说明 ValueOperations string 类型的数据操作 HashOperations map 类型的数据操作 ListOperations list 类型的数据操作 SetOperations set 类型数据操作 ZSetOperations zset 类型数据操作 # redis 的相关类型操作 # String","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"}],"tags":[]},{"title":"分布式系统","slug":"分布式系统","date":"2022-09-07T12:11:26.668Z","updated":"2023-02-17T06:15:23.555Z","comments":true,"path":"2022/09/07/分布式系统/","link":"","permalink":"http://example.com/2022/09/07/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"l&lt;!--swig￼0--># 分布式系统 # 概论 分布式 CAP 理论 分布式 BASE 理论 seata 在 windows 下的安装 # CAP CAP 理论是分布式系统、特别是分布式存储领域中被讨论的最多的理论。其中 C 代表一致性 (Consistency)，A 代表可用性 (Availability)，P 代表分区容错性 (Partition tolerance)。CAP 理论告诉我们 C、A、P 三者不能同时满足，最多只能满足其中两个。 &lt;img src=&quot;C:\\Users\\14023\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220907131016759.png&quot; alt=&quot;image-20220907131016759&quot; style=&quot;zoom:50%;&quot; /&gt; 1998 年，加州大学的计算机科学家 Eric Brewer 提出，分布式系统有三个指标。 指标 说明 Consistency（一致性） all nodes see the same data at the same time 在更新操作成功并返回客户端完成后，所有节点在同一个时间的数据完全一致。 这里的一致性是指强一致性。一般关系型数据库就具有强一致性特性。 Availability（可用性） Reads and writes always succeed 服务一直可用，而且是正常响应时间。 Partition tolerance （分区容错性） the system continues to operate despite arbirary message loss or failure of part of the system 分布式系统在遇到某节点或网络分区故障时，仍然能够对外提供满足一致性和可用性的服务。 Eric Brewer 指出，这三个指标不可能同时做到。这个结论就叫做 CAP 定理。由于 CAP 三需求无法同时满足，因此在设计分布式系统时就必须有所取舍。 由于网络并非 100% 可靠，因此分布式系统必须实现分区容错性，所以，系统架构师权衡取舍的也就只有 C（ 一致性 ）和 A（ 可用性 ），即，CP 还是 AP 。 如果此时要保证一致性，就必须等待网络恢复，完成数据同步后，整个集群才对外提供服务，服务处于阻塞状态，不可用。 CP ，即实现一致性和分区容错性。此组合为数据强一致性模式，即，要求在多服务之间数据一定要一致，弱化了可用性。一些对数据要求比较高的场景（ 比如金融业务 ）常使用此模式。这种模式性能较低。Seata AT 模式的 “读已提交” 级别就是这种模式。 如果此时要保证可用性，就不能等待网络恢复，那节点之间就会出现数据不一致。 AP，即实现可用性和分区容错性。此组合为数据最终一致性，即，要求所有服务器都可用，弱化了一致性。互联网分布式服务多数基于 AP 。这种模式性能较高，可满足高并发业务需求。基于消息的最终一致性就是这种模式。 也就是说，在 P 一定会出现的情况下，A 和 C 之间只能实现一个。 # CAP 三选二 一致性 (Consistency) : 一个写操作返回成功，那么之后的读请求都必须读到这个新数据；如果返回失败，那么所有读操作都不能读到这个数据。所有节点访问同一份最新的数据。 可用性 (Availability) : 对数据更新具备高可用性，请求能够及时处理，不会一直等待，即使出现节点失效。 分区容错性 (Partition tolerance) : 能容忍网络分区，在网络断开的情况下，被分隔的节点仍能正常对外提供服务。 # BASE # 什么是 BASE eBay 的架构师 Dan Pritchett 源于对大规模分布式系统的实践总结，在 ACM 上发表文章提出 BASE 理论，BASE 理论是对 CAP 理论的延伸，核心思想是即使无法做到强一致性（Strong Consistency，CAP 的一致性就是强一致性），但应用可以采用适合的方式达到最终一致性（Eventual Consitency）。 # 基本思想 BASE 理论包含三个思想： Basically Available（基本可用）：分布式系统在出现故障时，允许损失部分可用性，即保证核心可用。 Soft State（软状态）：在一定时间内，允许出现中间状态，比如临时的不一致状态。 Eventually Consistent（最终一致性）：虽然无法保证强一致性，但是在软状态结束后，最终达到数据一致。","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"}],"tags":[]},{"title":"Spring Security 认证鉴权(一)","slug":"springsecurity","date":"2022-09-06T04:49:10.401Z","updated":"2023-05-15T07:28:37.724Z","comments":true,"path":"2022/09/06/springsecurity/","link":"","permalink":"http://example.com/2022/09/06/springsecurity/","excerpt":"","text":"# 安全框架 SpringSecurity 鉴权 - [重点] SpringSecurity 整合 JWT - [重点] SpringSecurity 注销成功的处理 # 1.SpringSecurity 鉴权 RBAC 基于角色访问控制 Role-Based Access Control组成部分:RBAC模型里面，有3个基础组成部分，分别是：用户user、角色role 和 权限permssionUser（用户）：每个用户都有唯一的UID识别，并被授予不同的角色Role（角色）：不同角色具有不同的权限Permission（权限）：访问权限用户-角色映射：用户和角色之间的映射关系角色-权限映射：角色和权限之间的映射-- 基于资源(权限) 细粒 用户-权限SELECT p.* FROM rbac_perms p INNER JOIN rbac_user_perm up ON p.id=up.permid INNER JOIN rbac_user u ON u.id=up.userid WHERE u.username='zhangsan'-- 基于角色 粗粒度 用户-角色-权限SELECT p.* FROM rbac_perms p INNER JOIN rbac_role_perm rp ON p.id=rp.permid INNER JOIN rbac_user_role ur ON rp.roleid=ur.roleid INNER JOIN rbac_user u ON u.id=ur.userid WHERE u.username='zhangsan' 配置类注解 step1: 在配置类上添加 @EnableWebSecurity step2: 配置类上添加 @EnableGlobalMethodSecurity 指定 scecurity 鉴权时使用的是哪一套注解 Spring Security 支持三套注解： jsr250 注解 @DenyAll、@PermitAll、@RolesAllowed secured 注解 @Secured prePost 注解 @PreAuthorize、@PostAuthorize 实现步骤: (1) 在配置类上添加注解配置 @EnableWebSecurity//@EnableGlobalMethodSecurity (jsr250Enabled = true) // 开启 Security 注解鉴权//@EnableGlobalMethodSecurity(securedEnabled = true)@EnableGlobalMethodSecurity(prePostEnabled = true) //sprintSecurity 自带 可以支持 Spring EL 表达式public class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123; ...&#125;(2) 在控制器方法上使用注解，表示必须拥有该注解标识的权限才能访问 @RestControllerpublic class UserController &#123; @Autowired private UserService userService; @RequestMapping(\"/userList\") // 一旦使用此注解，表示请求该方法的用户权限集里必须该权限标识符 //@RolesAllowed (\"ROLE_teacher:list\") // 访问到数据库表中的权限标识符必须以 ROLE_开头，注解上的 ROLE_可以省略 //@Secured (\"ROLE_teacher:list\") // 访问到数据库表中的权限标识符必须以 ROLE_开头 注解上的 ROLE_不能省略 //@PreAuthorize (\"hasAnyAuthority ('teacher:list')\") // 使用 hashAnyAuthority EL 表达式，可以指定权限标识，不要求使用 ROL_ 开头 //@PreAuthorize (\"hasAnyRole ('ROLE_teacher:list')\") // 使用 hashAnyROLE EL 表达式，可以指定权限标识，要求使用 ROL_ 开头，数据库表中的权限标识也必须以 ROLE 开头 @PreAuthorize(\"hasRole('ROLE_teacher:list')\") public List&lt;User> queryUserList()&#123; return userService.list(null); &#125;&#125; 权限不足的处理方案 /** * 权限不足的处理 */@Componentpublic class MyAccessDeniedHandler implements AccessDeniedHandler &#123; public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException e) throws IOException, ServletException &#123; ResponseResult&lt;Void> result = ResponseResult.error(ResultCode.NO_PERMISSION); response.setContentType(\"application/json;charset=utf-8\"); PrintWriter out= response.getWriter(); out.write(new ObjectMapper().writeValueAsString(result)); // 将对象转 json 输出 out.flush(); out.close(); &#125;&#125;配置类 http.authorizeRequests().antMatchers(\"/login\", \"/login.html\") .permitAll().anyRequest().authenticated() .and(). // 设置登陆页、登录表单 form 中 action 的地址，也就是处理认证请求的路径 formLogin().loginPage(\"/login.html\").loginProcessingUrl(\"/login\") // 登录表单 form 中密码输入框 input 的 name 名，不修改的话默认是 password .usernameParameter(\"username\").passwordParameter(\"password\") // 登录认证成功后默认转跳的路径 //.defaultSuccessUrl(\"/home\") // 前后端分离认证成功的处理器 - 输出 json .successHandler(myAuthenticationSuccessHandler) // 前后端分离认证失败的处理器 - 输出 json .failureHandler(myAuthenticationFailureHandler) .and() // 前后端分离处理未登录请求 .exceptionHandling().authenticationEntryPoint(myAuthenticationEntryPoint) // 前后端分离处理权限不足的请求 .accessDeniedHandler(myAccessDeniedHandler);//.failureUrl(\"/error1\").permitAll();// 关闭 CSRF 跨域攻击防御http.csrf().disable();# 2.SpringSecurity 整合 JWT - [重点] # 2-1 JWT 概述 有状态与无状态比较 有状态服务，即服务端需要记录每次会话的客户端信息，从而识别客户端身份有状态缺点是什么？ - 服务端保存大量数据，增加服务端压力 - 服务端保存用户状态，无法进行水平扩展 - 客户端请求依赖服务端，多次请求必须访问同一台服务器服务器不需要记录客户端的状态信息:无状态服务器优点: - 客户端请求不依赖服务端的信息，任何多次请求不需要必须访问到同一台服务 - 服务端的集群和状态对客户端透明 - 服务端可以任意的迁移和伸缩 - 减小服务端存储压力 无状态登录流程 (1) 当客户端第一次请求服务时，服务端对用户进行信息认证（登录）(2) 认证通过，将用户信息进行加密形成token字符串 [自我描述信息](3) 将生成token串发送到客户端(4) 以后每次请求，客户端都携带认证的token (5) 服务的对token进行解密，判断是否有效。 JWT 的 Token 串生成 JWT 全称是 Json Web Token 是 JSON 风格轻量级的授权和身份认证规范 JWT 的 Token 串由三部分组成 header 头信息 - 采用 base64 编码生成 -- 类型与生成时间 Payload 载荷 - 用户身份信息，过期时间，签发人 - 采用 base64 编码 Signature 签名 是整个数据的认证信息 - header+Payload + 密钥 secret-RSA 非对称加密技术生成 使用 JWT 实现服务端交互流程: - 1、用户登录- 2、服务的认证，通过后根据secret生成token- 3、将生成的token返回给浏览器- 4、用户每次请求携带token --header 通过客户端的请求头发送token串- 5、服务端利用公钥解读jwt签名，判断签名有效后，从Payload中获取用户信息- 6、处理请求，返回响应结果# 2-2 实现生成 token 添加依赖 jar &lt;!-- 用于生成 JWT 依赖 -->&lt;dependency> &lt;groupId>io.jsonwebtoken&lt;/groupId> &lt;artifactId>jjwt&lt;/artifactId> &lt;version>0.9.1&lt;/version>&lt;/dependency>&lt;dependency> &lt;groupId>com.auth0&lt;/groupId> &lt;artifactId>java-jwt&lt;/artifactId> &lt;version>3.8.1&lt;/version>&lt;/dependency> 编写工具类 JwtTokenUtil 并测试 public class JwtTokenUtil &#123; /** * 过期时间 50 分钟 */ private static final long EXPIRE_TIME = 5 * 60 * 10000; /** * jwt 密钥 */ private static final String SECRET = \"password\"; /* 生成签名 50 分钟过期 */ public static String createSign(String userName) throws Exception &#123; try &#123; Date date = new Date(System.currentTimeMillis() + EXPIRE_TIME); Algorithm algorithm = Algorithm.HMAC256(SECRET); return JWT.create() // 将 user id 保存到 token 里面 .withAudience(userName) // 50 分钟后 token 过期 .withExpiresAt(date) //.withClaim() //.withSubject(userName) //token 的密钥 .sign(algorithm); &#125;catch(Exception ex)&#123; ex.printStackTrace(); throw new Exception(\"签名错误\"); &#125; &#125; /** * 根据 token 获取 username * @param token * @return */ public static String getUserId(String token) &#123; try &#123; String userId = JWT.decode(token).getAudience().get(0); return userId; &#125; catch (JWTDecodeException e) &#123; throw new JWTDecodeException(\"生成的token 异常\"); &#125; &#125; /** * 校验 token 是否有效 * @param token * @return */ public static boolean checkSign(String token) &#123; try &#123; Algorithm algorithm = Algorithm.HMAC256(SECRET); JWTVerifier verifier = JWT.require(algorithm) // .withClaim(\"username\", username) .build(); DecodedJWT jwt = verifier.verify(token); return true; &#125; catch (JWTVerificationException exception) &#123; throw new RuntimeException(\"token 无效，请重新获取\"); &#125; &#125; public static void main(String[] args) throws Exception &#123; // 测试生成 Token 串 String strToken = JwtTokenUtil.createSign(\"zhangsan\"); System.out.println(strToken); //eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJhdWQiOiJ6aGFuZ3NhbiIsImV4cCI6MTY1NzA5MzQ3MX0.OdoENj363dPW2YVQfrc4SigoYlt45ydEtkgIc4xzzRo // 验证 token 是否有效 boolean isValid = JwtTokenUtil.checkSign(\"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJhdWQiOiJ6aGFuZ3NhbiIsImV4cCI6MTY1NzA5MzQ3MX0.OdoENj363dPW2YVQfrc4SigoYlt45ydEtkgIc4xzzRo\"); System.out.println(isValid); // 从给定的 token 串获取用户信息 String username = JwtTokenUtil.getUserId(\"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJhdWQiOiJ6aGFuZ3NhbiIsImV4cCI6MTY1NzA5MzQ3MX0.OdoENj363dPW2YVQfrc4SigoYlt45ydEtkgIc4xzzRo\"); System.out.println(username); &#125;&#125;# 2-3 SpringSecurity 整合 JWT - 返回 JWT token 第 1 步，登录认证成功，生成 token 并返回 ** * 自定义认证成功的处理器Handler */@Componentpublic class MyAuthenticationSuccessHandler implements AuthenticationSuccessHandler &#123; @Override public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException &#123; try &#123; // 获取当前登录认证成功的用户名 String username = request.getParameter(\"username\"); String strToken = JwtTokenUtil.createSign(username); // 通过响应的 json 返回客户端 ResponseResult&lt;String> result = new ResponseResult&lt;>(strToken,\"OK\",200); response.setContentType(\"application/json;charset=utf-8\"); PrintWriter out = response.getWriter(); // 将对象转 json 输出 out.write(new ObjectMapper().writeValueAsString(result)); out.flush(); out.close(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125;第 2 步，携带 Token 发送请求 要想使 FilterSecurityInterceptor 过滤器放行: 1. Spring Security 上下文（ Context ） 中要有一个 Authentication Token ，且应该是已认证状态。2. Authentication Token 中所包含的 User 的权限信息要满足访问当前 URI 的权限要求。实现思路: 关键在于：在 FilterSecurityInterceptor 之前 要有一个 Filter 将用户请求中携带的 JWT 转化为 Authentication Token 存在 Spring Security 上下文（ Context ）中给 “后面” 的 FilterSecurityInterceptor 用。 基于上述思路，我们要自定义实现一个 Filter ： /** * 将用户请求中携带的 JWT 转化为 Authentication Token * 存入 Spring Security 上下文（ Context ） * 表示每次请求只执行该过滤器一次 */@Componentpublic class JwtTokenAuthenticationFilter extends OncePerRequestFilter &#123; @Autowired private UserMapper userMapper; @Autowired private MyAuthenticationFailureHandler myAuthenticationFailureHandler; @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123; // 获取当前请求的 uri String uri = request.getRequestURI(); // 如果是认证请求 if(uri.endsWith(\"/login\"))&#123; // 放行 filterChain.doFilter(request,response); return; &#125; // 不是认证请求 -- 获取请求中的头部的 token 串 String strToken = request.getHeader(\"strToken\"); if(StringUtils.isEmpty(strToken))&#123; // 抛出自定义异常 -Token 为 null myAuthenticationFailureHandler.onAuthenticationFailure(request,response, new TokenIsNullException(\"Token为空!\")); return ; &#125; // 不是空，且不是认证请求 try &#123; // 检验 token 是否有效 if (JwtTokenUtil.checkSign(strToken)) &#123; // 获取 token 中的用户名 String username = JwtTokenUtil.getUserId(strToken); // 查询数据库获取用户的权限集 List&lt;String> percodes = userMapper.getPerCodesByPerm(username); List&lt;GrantedAuthority> authorities = new ArrayList&lt;>(); percodes.forEach(percode->&#123; authorities.add(new SimpleGrantedAuthority(percode)); &#125;); // 封装数据库存询的用户信息 UsernamePasswordAuthenticationToken usernamePasswordAuthenticationToken = new UsernamePasswordAuthenticationToken(username,\"\",authorities); // 存入 securityContext SecurityContextHolder.getContext().setAuthentication(usernamePasswordAuthenticationToken); // 放行 filterChain.doFilter(request,response); &#125; &#125;catch(Exception e)&#123; /// 抛出自定义异常 Token 无效 myAuthenticationFailureHandler.onAuthenticationFailure(request,response, new TokenIsInvalidException(\"Token无效!\")); &#125; &#125;&#125;然后将过滤器插入到 FilterChainPrxoy 代理的过滤器链中的 UsernamePasswordAuthencationFilter 前面 // 将自定义的 JwtTokenAuthenticationFilter 插入到过滤器链中的指定的过滤器前面 http.addFilterBefore(jwtTokenAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);# 3. 注销成功处理方案 注销成功之后返回登录的页面，逻辑是没有错的，但是在前后端分离的情况下是返回登录页面吗？显然不是，而是返回注销成功的信息 于是，我们再去定制一个 LogoutSuccessHandler // 注销成功的处理器@Componentpublic class MyLogoutSuccessHandler implements LogoutSuccessHandler &#123; @Override public void onLogoutSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException &#123; String headerToken = request.getHeader(\"strToken\"); System.out.println(\"logout header Token:\"+headerToken); if(!StringUtils.isEmpty(headerToken))&#123; // 如果 token 不是空 SecurityContextHolder.clearContext(); // 清空上下文 用户名与权限集 UsernamePasswordAuthenticationToken ResponseResult&lt;String> result = new ResponseResult&lt;>(\"\",\"注销成功\",200); response.setContentType(\"application/json;charset=UTF-8\"); response.getWriter().write(new ObjectMapper().writeValueAsString(result)); &#125;else&#123; ResponseResult&lt;Void> result = ResponseResult.error(ResultCode.TOKEN_IS_NULL); response.setContentType(\"application/json;charset=utf-8\"); PrintWriter out= response.getWriter(); out.write(new ObjectMapper().writeValueAsString(result)); // 将对象转 json 输出 out.flush(); out.close(); &#125; &#125;&#125;WebSecurityConfig 配置类中 配置注销成功处理器 // 前后端分离处理注销成功操作 .and().logout().logoutSuccessHandler(myLogoutSuccessHandler);// 关闭 session 最严格的策略 -JWT 认证的情况下，不需要 security 会话参与 http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS);","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"}],"tags":[]}],"categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"},{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}],"tags":[]}